# Code generated by protox. Don't edit.
# credo:disable-for-this-file
defmodule PgQuery.Query do
  @moduledoc false
  if function_exported?(Protox, :check_generator_version, 1) do
    Protox.check_generator_version(1)
  else
    raise "This code was generated with protox 2 but the runtime is using an older version of protox."
  end

  @type t :: %__MODULE__{
          stmt_len: integer(),
          stmt_location: integer(),
          with_check_options: [PgQuery.Node.t()],
          constraint_deps: [PgQuery.Node.t()],
          set_operations: PgQuery.Node.t() | nil,
          row_marks: [PgQuery.Node.t()],
          limit_option: atom(),
          limit_count: PgQuery.Node.t() | nil,
          limit_offset: PgQuery.Node.t() | nil,
          sort_clause: [PgQuery.Node.t()],
          distinct_clause: [PgQuery.Node.t()],
          window_clause: [PgQuery.Node.t()],
          having_qual: PgQuery.Node.t() | nil,
          grouping_sets: [PgQuery.Node.t()],
          group_distinct: boolean(),
          group_clause: [PgQuery.Node.t()],
          returning_list: [PgQuery.Node.t()],
          on_conflict: PgQuery.OnConflictExpr.t() | nil,
          override: atom(),
          target_list: [PgQuery.Node.t()],
          merge_use_outer_join: boolean(),
          merge_action_list: [PgQuery.Node.t()],
          jointree: PgQuery.FromExpr.t() | nil,
          rtable: [PgQuery.Node.t()],
          cte_list: [PgQuery.Node.t()],
          is_return: boolean(),
          has_row_security: boolean(),
          has_for_update: boolean(),
          has_modifying_cte: boolean(),
          has_recursive: boolean(),
          has_distinct_on: boolean(),
          has_sub_links: boolean(),
          has_target_srfs: boolean(),
          has_window_funcs: boolean(),
          has_aggs: boolean(),
          result_relation: integer(),
          utility_stmt: PgQuery.Node.t() | nil,
          can_set_tag: boolean(),
          query_source: atom(),
          command_type: atom(),
          __uf__: [{non_neg_integer(), Protox.Types.tag(), binary()}]
        }
  defstruct stmt_len: 0,
            stmt_location: 0,
            with_check_options: [],
            constraint_deps: [],
            set_operations: nil,
            row_marks: [],
            limit_option: :LIMIT_OPTION_UNDEFINED,
            limit_count: nil,
            limit_offset: nil,
            sort_clause: [],
            distinct_clause: [],
            window_clause: [],
            having_qual: nil,
            grouping_sets: [],
            group_distinct: false,
            group_clause: [],
            returning_list: [],
            on_conflict: nil,
            override: :OVERRIDING_KIND_UNDEFINED,
            target_list: [],
            merge_use_outer_join: false,
            merge_action_list: [],
            jointree: nil,
            rtable: [],
            cte_list: [],
            is_return: false,
            has_row_security: false,
            has_for_update: false,
            has_modifying_cte: false,
            has_recursive: false,
            has_distinct_on: false,
            has_sub_links: false,
            has_target_srfs: false,
            has_window_funcs: false,
            has_aggs: false,
            result_relation: 0,
            utility_stmt: nil,
            can_set_tag: false,
            query_source: :QUERY_SOURCE_UNDEFINED,
            command_type: :CMD_TYPE_UNDEFINED,
            __uf__: []

  (
    (
      @spec encode(t()) :: {:ok, iodata(), non_neg_integer()} | {:error, any()}
      def encode(msg) do
        msg |> encode!() |> Tuple.insert_at(0, :ok)
      rescue
        e in [Protox.EncodingError, Protox.RequiredFieldsError] -> {:error, e}
      end

      @spec encode!(t()) :: {iodata(), non_neg_integer()} | no_return()
      def encode!(msg) do
        {_acc = [], _acc_size = 0}
        |> encode_stmt_len(msg)
        |> encode_stmt_location(msg)
        |> encode_with_check_options(msg)
        |> encode_constraint_deps(msg)
        |> encode_set_operations(msg)
        |> encode_row_marks(msg)
        |> encode_limit_option(msg)
        |> encode_limit_count(msg)
        |> encode_limit_offset(msg)
        |> encode_sort_clause(msg)
        |> encode_distinct_clause(msg)
        |> encode_window_clause(msg)
        |> encode_having_qual(msg)
        |> encode_grouping_sets(msg)
        |> encode_group_distinct(msg)
        |> encode_group_clause(msg)
        |> encode_returning_list(msg)
        |> encode_on_conflict(msg)
        |> encode_override(msg)
        |> encode_target_list(msg)
        |> encode_merge_use_outer_join(msg)
        |> encode_merge_action_list(msg)
        |> encode_jointree(msg)
        |> encode_rtable(msg)
        |> encode_cte_list(msg)
        |> encode_is_return(msg)
        |> encode_has_row_security(msg)
        |> encode_has_for_update(msg)
        |> encode_has_modifying_cte(msg)
        |> encode_has_recursive(msg)
        |> encode_has_distinct_on(msg)
        |> encode_has_sub_links(msg)
        |> encode_has_target_srfs(msg)
        |> encode_has_window_funcs(msg)
        |> encode_has_aggs(msg)
        |> encode_result_relation(msg)
        |> encode_utility_stmt(msg)
        |> encode_can_set_tag(msg)
        |> encode_query_source(msg)
        |> encode_command_type(msg)
        |> encode_unknown_fields(msg)
      end
    )

    defp encode_stmt_len({acc, acc_size}, msg) do
      if msg.stmt_len == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_int32(msg.stmt_len)
        {["\xC0\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:stmt_len, "invalid field value"), __STACKTRACE__
    end

    defp encode_stmt_location({acc, acc_size}, msg) do
      if msg.stmt_location == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_int32(msg.stmt_location)
        {["\xB8\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:stmt_location, "invalid field value"), __STACKTRACE__
    end

    defp encode_with_check_options({acc, acc_size}, msg) do
      case msg.with_check_options do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xB2\x02" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:with_check_options, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_constraint_deps({acc, acc_size}, msg) do
      case msg.constraint_deps do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xAA\x02" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:constraint_deps, "invalid field value"), __STACKTRACE__
    end

    defp encode_set_operations({acc, acc_size}, msg) do
      if msg.set_operations == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.set_operations)
        {["\xA2\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:set_operations, "invalid field value"), __STACKTRACE__
    end

    defp encode_row_marks({acc, acc_size}, msg) do
      case msg.row_marks do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\x9A\x02" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:row_marks, "invalid field value"), __STACKTRACE__
    end

    defp encode_limit_option({acc, acc_size}, msg) do
      if msg.limit_option == :LIMIT_OPTION_UNDEFINED do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} =
          msg.limit_option |> PgQuery.LimitOption.encode() |> Protox.Encode.encode_enum()

        {["\x90\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:limit_option, "invalid field value"), __STACKTRACE__
    end

    defp encode_limit_count({acc, acc_size}, msg) do
      if msg.limit_count == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.limit_count)
        {["\x8A\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:limit_count, "invalid field value"), __STACKTRACE__
    end

    defp encode_limit_offset({acc, acc_size}, msg) do
      if msg.limit_offset == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.limit_offset)
        {["\x82\x02", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:limit_offset, "invalid field value"), __STACKTRACE__
    end

    defp encode_sort_clause({acc, acc_size}, msg) do
      case msg.sort_clause do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xFA\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:sort_clause, "invalid field value"), __STACKTRACE__
    end

    defp encode_distinct_clause({acc, acc_size}, msg) do
      case msg.distinct_clause do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xF2\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:distinct_clause, "invalid field value"), __STACKTRACE__
    end

    defp encode_window_clause({acc, acc_size}, msg) do
      case msg.window_clause do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xEA\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:window_clause, "invalid field value"), __STACKTRACE__
    end

    defp encode_having_qual({acc, acc_size}, msg) do
      if msg.having_qual == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.having_qual)
        {["\xE2\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:having_qual, "invalid field value"), __STACKTRACE__
    end

    defp encode_grouping_sets({acc, acc_size}, msg) do
      case msg.grouping_sets do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xDA\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:grouping_sets, "invalid field value"), __STACKTRACE__
    end

    defp encode_group_distinct({acc, acc_size}, msg) do
      if msg.group_distinct == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.group_distinct)
        {["\xD0\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:group_distinct, "invalid field value"), __STACKTRACE__
    end

    defp encode_group_clause({acc, acc_size}, msg) do
      case msg.group_clause do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xCA\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:group_clause, "invalid field value"), __STACKTRACE__
    end

    defp encode_returning_list({acc, acc_size}, msg) do
      case msg.returning_list do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xC2\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:returning_list, "invalid field value"), __STACKTRACE__
    end

    defp encode_on_conflict({acc, acc_size}, msg) do
      if msg.on_conflict == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.on_conflict)
        {["\xBA\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:on_conflict, "invalid field value"), __STACKTRACE__
    end

    defp encode_override({acc, acc_size}, msg) do
      if msg.override == :OVERRIDING_KIND_UNDEFINED do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} =
          msg.override |> PgQuery.OverridingKind.encode() |> Protox.Encode.encode_enum()

        {["\xB0\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:override, "invalid field value"), __STACKTRACE__
    end

    defp encode_target_list({acc, acc_size}, msg) do
      case msg.target_list do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\xAA\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:target_list, "invalid field value"), __STACKTRACE__
    end

    defp encode_merge_use_outer_join({acc, acc_size}, msg) do
      if msg.merge_use_outer_join == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.merge_use_outer_join)
        {["\xA0\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:merge_use_outer_join, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_merge_action_list({acc, acc_size}, msg) do
      case msg.merge_action_list do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\x9A\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:merge_action_list, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_jointree({acc, acc_size}, msg) do
      if msg.jointree == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.jointree)
        {["\x92\x01", value_bytes | acc], acc_size + 2 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:jointree, "invalid field value"), __STACKTRACE__
    end

    defp encode_rtable({acc, acc_size}, msg) do
      case msg.rtable do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\x8A\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:rtable, "invalid field value"), __STACKTRACE__
    end

    defp encode_cte_list({acc, acc_size}, msg) do
      case msg.cte_list do
        [] ->
          {acc, acc_size}

        values ->
          {value_bytes, value_size} =
            (
              {value_bytes, value_size} =
                Enum.reduce(values, {_local_acc = [], _local_acc_size = 0}, fn value,
                                                                               {local_acc,
                                                                                local_acc_size} ->
                  {value_bytes, value_bytes_size} = Protox.Encode.encode_message(value)
                  {[value_bytes, "\x82\x01" | local_acc], local_acc_size + 2 + value_bytes_size}
                end)

              {Enum.reverse(value_bytes), value_size}
            )

          {[value_bytes | acc], acc_size + value_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:cte_list, "invalid field value"), __STACKTRACE__
    end

    defp encode_is_return({acc, acc_size}, msg) do
      if msg.is_return == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.is_return)
        {["x", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:is_return, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_row_security({acc, acc_size}, msg) do
      if msg.has_row_security == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_row_security)
        {["p", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_row_security, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_for_update({acc, acc_size}, msg) do
      if msg.has_for_update == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_for_update)
        {["h", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_for_update, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_modifying_cte({acc, acc_size}, msg) do
      if msg.has_modifying_cte == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_modifying_cte)
        {["`", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_modifying_cte, "invalid field value"),
                __STACKTRACE__
    end

    defp encode_has_recursive({acc, acc_size}, msg) do
      if msg.has_recursive == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_recursive)
        {["X", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_recursive, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_distinct_on({acc, acc_size}, msg) do
      if msg.has_distinct_on == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_distinct_on)
        {["P", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_distinct_on, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_sub_links({acc, acc_size}, msg) do
      if msg.has_sub_links == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_sub_links)
        {["H", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_sub_links, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_target_srfs({acc, acc_size}, msg) do
      if msg.has_target_srfs == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_target_srfs)
        {["@", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_target_srfs, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_window_funcs({acc, acc_size}, msg) do
      if msg.has_window_funcs == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_window_funcs)
        {["8", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_window_funcs, "invalid field value"), __STACKTRACE__
    end

    defp encode_has_aggs({acc, acc_size}, msg) do
      if msg.has_aggs == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.has_aggs)
        {["0", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:has_aggs, "invalid field value"), __STACKTRACE__
    end

    defp encode_result_relation({acc, acc_size}, msg) do
      if msg.result_relation == 0 do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_int32(msg.result_relation)
        {["(", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:result_relation, "invalid field value"), __STACKTRACE__
    end

    defp encode_utility_stmt({acc, acc_size}, msg) do
      if msg.utility_stmt == nil do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_message(msg.utility_stmt)
        {["\"", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:utility_stmt, "invalid field value"), __STACKTRACE__
    end

    defp encode_can_set_tag({acc, acc_size}, msg) do
      if msg.can_set_tag == false do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} = Protox.Encode.encode_bool(msg.can_set_tag)
        {["\x18", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:can_set_tag, "invalid field value"), __STACKTRACE__
    end

    defp encode_query_source({acc, acc_size}, msg) do
      if msg.query_source == :QUERY_SOURCE_UNDEFINED do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} =
          msg.query_source |> PgQuery.QuerySource.encode() |> Protox.Encode.encode_enum()

        {["\x10", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:query_source, "invalid field value"), __STACKTRACE__
    end

    defp encode_command_type({acc, acc_size}, msg) do
      if msg.command_type == :CMD_TYPE_UNDEFINED do
        {acc, acc_size}
      else
        {value_bytes, value_bytes_size} =
          msg.command_type |> PgQuery.CmdType.encode() |> Protox.Encode.encode_enum()

        {["\b", value_bytes | acc], acc_size + 1 + value_bytes_size}
      end
    rescue
      ArgumentError ->
        reraise Protox.EncodingError.new(:command_type, "invalid field value"), __STACKTRACE__
    end

    defp encode_unknown_fields({acc, acc_size}, msg) do
      Enum.reduce(msg.__uf__, {acc, acc_size}, fn {tag, wire_type, bytes}, {acc, acc_size} ->
        case wire_type do
          0 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :int32)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}

          1 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :double)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}

          2 ->
            {len_bytes, len_size} = bytes |> byte_size() |> Protox.Varint.encode()
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :packed)

            {[acc, <<key_bytes::binary, len_bytes::binary, bytes::binary>>],
             acc_size + key_size + len_size + byte_size(bytes)}

          5 ->
            {key_bytes, key_size} = Protox.Encode.make_key_bytes(tag, :float)
            {[acc, <<key_bytes::binary, bytes::binary>>], acc_size + key_size + byte_size(bytes)}
        end
      end)
    end
  )

  (
    (
      @spec decode(binary()) :: {:ok, t()} | {:error, any()}
      def decode(bytes) do
        {:ok, decode!(bytes)}
      rescue
        e in [Protox.DecodingError, Protox.IllegalTagError, Protox.RequiredFieldsError] ->
          {:error, e}
      end

      (
        @spec decode!(binary()) :: t() | no_return()
        def decode!(bytes) do
          parse_key_value(bytes, struct(PgQuery.Query))
        end
      )
    )

    (
      @spec parse_key_value(binary(), struct()) :: struct()
      defp parse_key_value(<<>>, msg) do
        msg
      end

      defp parse_key_value(bytes, msg) do
        {field, rest} =
          case bytes do
            <<_::5, 3::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 3")

            <<_::5, 4::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 4")

            <<_::5, 6::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 6")

            <<_::5, 7::3, _rest::binary>> ->
              raise Protox.DecodingError.new(bytes, "invalid wire type 7")

            <<0::5, _::3, _rest::binary>> ->
              raise %Protox.IllegalTagError{}

            <<24::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_int32(bytes)
              {[stmt_len: value], rest}

            <<23::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_int32(bytes)
              {[stmt_location: value], rest}

            <<22::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[with_check_options: msg.with_check_options ++ [PgQuery.Node.decode!(delimited)]],
               rest}

            <<21::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[constraint_deps: msg.constraint_deps ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<20::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 set_operations:
                   Protox.MergeMessage.merge(msg.set_operations, PgQuery.Node.decode!(delimited))
               ], rest}

            <<19::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[row_marks: msg.row_marks ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<18::5, _wire_type::3, "\x02", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_enum(bytes, PgQuery.LimitOption)
              {[limit_option: value], rest}

            <<17::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 limit_count:
                   Protox.MergeMessage.merge(msg.limit_count, PgQuery.Node.decode!(delimited))
               ], rest}

            <<16::5, _wire_type::3, "\x02", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 limit_offset:
                   Protox.MergeMessage.merge(msg.limit_offset, PgQuery.Node.decode!(delimited))
               ], rest}

            <<31::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[sort_clause: msg.sort_clause ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<30::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[distinct_clause: msg.distinct_clause ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<29::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[window_clause: msg.window_clause ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<28::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 having_qual:
                   Protox.MergeMessage.merge(msg.having_qual, PgQuery.Node.decode!(delimited))
               ], rest}

            <<27::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[grouping_sets: msg.grouping_sets ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<26::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[group_distinct: value], rest}

            <<25::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[group_clause: msg.group_clause ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<24::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[returning_list: msg.returning_list ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<23::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 on_conflict:
                   Protox.MergeMessage.merge(
                     msg.on_conflict,
                     PgQuery.OnConflictExpr.decode!(delimited)
                   )
               ], rest}

            <<22::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_enum(bytes, PgQuery.OverridingKind)
              {[override: value], rest}

            <<21::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[target_list: msg.target_list ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<20::5, _wire_type::3, "\x01", bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[merge_use_outer_join: value], rest}

            <<19::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[merge_action_list: msg.merge_action_list ++ [PgQuery.Node.decode!(delimited)]],
               rest}

            <<18::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 jointree:
                   Protox.MergeMessage.merge(msg.jointree, PgQuery.FromExpr.decode!(delimited))
               ], rest}

            <<17::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[rtable: msg.rtable ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<16::5, _wire_type::3, "\x01", bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)
              {[cte_list: msg.cte_list ++ [PgQuery.Node.decode!(delimited)]], rest}

            <<15::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[is_return: value], rest}

            <<14::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_row_security: value], rest}

            <<13::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_for_update: value], rest}

            <<12::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_modifying_cte: value], rest}

            <<11::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_recursive: value], rest}

            <<10::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_distinct_on: value], rest}

            <<9::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_sub_links: value], rest}

            <<8::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_target_srfs: value], rest}

            <<7::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_window_funcs: value], rest}

            <<6::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[has_aggs: value], rest}

            <<5::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_int32(bytes)
              {[result_relation: value], rest}

            <<4::5, _wire_type::3, bytes::binary>> ->
              {len, bytes} = Protox.Varint.decode(bytes)
              {delimited, rest} = Protox.Decode.parse_delimited(bytes, len)

              {[
                 utility_stmt:
                   Protox.MergeMessage.merge(msg.utility_stmt, PgQuery.Node.decode!(delimited))
               ], rest}

            <<3::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_bool(bytes)
              {[can_set_tag: value], rest}

            <<2::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_enum(bytes, PgQuery.QuerySource)
              {[query_source: value], rest}

            <<1::5, _wire_type::3, bytes::binary>> ->
              {value, rest} = Protox.Decode.parse_enum(bytes, PgQuery.CmdType)
              {[command_type: value], rest}

            <<bytes::binary>> ->
              {tag, wire_type, rest} = Protox.Decode.parse_key(bytes)
              {value, rest} = Protox.Decode.parse_unknown(tag, wire_type, rest)
              {[__uf__: msg.__uf__ ++ [value]], rest}
          end

        msg_updated = struct(msg, field)
        parse_key_value(rest, msg_updated)
      end
    )
  )

  (
    @spec unknown_fields(struct()) :: [{non_neg_integer(), Protox.Types.tag(), binary()}]
    def unknown_fields(msg) do
      msg.__uf__
    end

    @spec unknown_fields_name() :: :__uf__
    def unknown_fields_name() do
      :__uf__
    end

    @spec clear_unknown_fields(struct) :: struct
    def clear_unknown_fields(msg) do
      struct!(msg, __uf__: [])
    end
  )

  (
    @spec default(atom()) ::
            {:ok, boolean() | integer() | String.t() | float()}
            | {:error, :no_such_field | :no_default_value}
    def default(:stmt_len) do
      {:ok, 0}
    end

    def default(:stmt_location) do
      {:ok, 0}
    end

    def default(:with_check_options) do
      {:error, :no_default_value}
    end

    def default(:constraint_deps) do
      {:error, :no_default_value}
    end

    def default(:set_operations) do
      {:ok, nil}
    end

    def default(:row_marks) do
      {:error, :no_default_value}
    end

    def default(:limit_option) do
      {:ok, :LIMIT_OPTION_UNDEFINED}
    end

    def default(:limit_count) do
      {:ok, nil}
    end

    def default(:limit_offset) do
      {:ok, nil}
    end

    def default(:sort_clause) do
      {:error, :no_default_value}
    end

    def default(:distinct_clause) do
      {:error, :no_default_value}
    end

    def default(:window_clause) do
      {:error, :no_default_value}
    end

    def default(:having_qual) do
      {:ok, nil}
    end

    def default(:grouping_sets) do
      {:error, :no_default_value}
    end

    def default(:group_distinct) do
      {:ok, false}
    end

    def default(:group_clause) do
      {:error, :no_default_value}
    end

    def default(:returning_list) do
      {:error, :no_default_value}
    end

    def default(:on_conflict) do
      {:ok, nil}
    end

    def default(:override) do
      {:ok, :OVERRIDING_KIND_UNDEFINED}
    end

    def default(:target_list) do
      {:error, :no_default_value}
    end

    def default(:merge_use_outer_join) do
      {:ok, false}
    end

    def default(:merge_action_list) do
      {:error, :no_default_value}
    end

    def default(:jointree) do
      {:ok, nil}
    end

    def default(:rtable) do
      {:error, :no_default_value}
    end

    def default(:cte_list) do
      {:error, :no_default_value}
    end

    def default(:is_return) do
      {:ok, false}
    end

    def default(:has_row_security) do
      {:ok, false}
    end

    def default(:has_for_update) do
      {:ok, false}
    end

    def default(:has_modifying_cte) do
      {:ok, false}
    end

    def default(:has_recursive) do
      {:ok, false}
    end

    def default(:has_distinct_on) do
      {:ok, false}
    end

    def default(:has_sub_links) do
      {:ok, false}
    end

    def default(:has_target_srfs) do
      {:ok, false}
    end

    def default(:has_window_funcs) do
      {:ok, false}
    end

    def default(:has_aggs) do
      {:ok, false}
    end

    def default(:result_relation) do
      {:ok, 0}
    end

    def default(:utility_stmt) do
      {:ok, nil}
    end

    def default(:can_set_tag) do
      {:ok, false}
    end

    def default(:query_source) do
      {:ok, :QUERY_SOURCE_UNDEFINED}
    end

    def default(:command_type) do
      {:ok, :CMD_TYPE_UNDEFINED}
    end

    def default(_) do
      {:error, :no_such_field}
    end
  )

  @spec schema() :: Protox.MessageSchema.t()
  def schema() do
    %{
      __struct__: Protox.MessageSchema,
      fields: %{
        can_set_tag: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :can_set_tag,
          tag: 3,
          type: :bool
        },
        command_type: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: :CMD_TYPE_UNDEFINED},
          label: :optional,
          name: :command_type,
          tag: 1,
          type: {:enum, PgQuery.CmdType}
        },
        constraint_deps: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :constraint_deps,
          tag: 37,
          type: {:message, PgQuery.Node}
        },
        cte_list: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :cte_list,
          tag: 16,
          type: {:message, PgQuery.Node}
        },
        distinct_clause: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :distinct_clause,
          tag: 30,
          type: {:message, PgQuery.Node}
        },
        group_clause: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :group_clause,
          tag: 25,
          type: {:message, PgQuery.Node}
        },
        group_distinct: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :group_distinct,
          tag: 26,
          type: :bool
        },
        grouping_sets: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :grouping_sets,
          tag: 27,
          type: {:message, PgQuery.Node}
        },
        has_aggs: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_aggs,
          tag: 6,
          type: :bool
        },
        has_distinct_on: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_distinct_on,
          tag: 10,
          type: :bool
        },
        has_for_update: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_for_update,
          tag: 13,
          type: :bool
        },
        has_modifying_cte: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_modifying_cte,
          tag: 12,
          type: :bool
        },
        has_recursive: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_recursive,
          tag: 11,
          type: :bool
        },
        has_row_security: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_row_security,
          tag: 14,
          type: :bool
        },
        has_sub_links: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_sub_links,
          tag: 9,
          type: :bool
        },
        has_target_srfs: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_target_srfs,
          tag: 8,
          type: :bool
        },
        has_window_funcs: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :has_window_funcs,
          tag: 7,
          type: :bool
        },
        having_qual: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :having_qual,
          tag: 28,
          type: {:message, PgQuery.Node}
        },
        is_return: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :is_return,
          tag: 15,
          type: :bool
        },
        jointree: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :jointree,
          tag: 18,
          type: {:message, PgQuery.FromExpr}
        },
        limit_count: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :limit_count,
          tag: 33,
          type: {:message, PgQuery.Node}
        },
        limit_offset: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :limit_offset,
          tag: 32,
          type: {:message, PgQuery.Node}
        },
        limit_option: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: :LIMIT_OPTION_UNDEFINED},
          label: :optional,
          name: :limit_option,
          tag: 34,
          type: {:enum, PgQuery.LimitOption}
        },
        merge_action_list: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :merge_action_list,
          tag: 19,
          type: {:message, PgQuery.Node}
        },
        merge_use_outer_join: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: false},
          label: :optional,
          name: :merge_use_outer_join,
          tag: 20,
          type: :bool
        },
        on_conflict: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :on_conflict,
          tag: 23,
          type: {:message, PgQuery.OnConflictExpr}
        },
        override: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: :OVERRIDING_KIND_UNDEFINED},
          label: :optional,
          name: :override,
          tag: 22,
          type: {:enum, PgQuery.OverridingKind}
        },
        query_source: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: :QUERY_SOURCE_UNDEFINED},
          label: :optional,
          name: :query_source,
          tag: 2,
          type: {:enum, PgQuery.QuerySource}
        },
        result_relation: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :result_relation,
          tag: 5,
          type: :int32
        },
        returning_list: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :returning_list,
          tag: 24,
          type: {:message, PgQuery.Node}
        },
        row_marks: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :row_marks,
          tag: 35,
          type: {:message, PgQuery.Node}
        },
        rtable: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :rtable,
          tag: 17,
          type: {:message, PgQuery.Node}
        },
        set_operations: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :set_operations,
          tag: 36,
          type: {:message, PgQuery.Node}
        },
        sort_clause: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :sort_clause,
          tag: 31,
          type: {:message, PgQuery.Node}
        },
        stmt_len: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :stmt_len,
          tag: 40,
          type: :int32
        },
        stmt_location: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: 0},
          label: :optional,
          name: :stmt_location,
          tag: 39,
          type: :int32
        },
        target_list: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :target_list,
          tag: 21,
          type: {:message, PgQuery.Node}
        },
        utility_stmt: %{
          __struct__: Protox.Field,
          kind: %{__struct__: Protox.Scalar, default_value: nil},
          label: :optional,
          name: :utility_stmt,
          tag: 4,
          type: {:message, PgQuery.Node}
        },
        window_clause: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :window_clause,
          tag: 29,
          type: {:message, PgQuery.Node}
        },
        with_check_options: %{
          __struct__: Protox.Field,
          kind: :unpacked,
          label: :repeated,
          name: :with_check_options,
          tag: 38,
          type: {:message, PgQuery.Node}
        }
      },
      file_options: nil,
      name: PgQuery.Query,
      syntax: :proto3
    }
  end
end
